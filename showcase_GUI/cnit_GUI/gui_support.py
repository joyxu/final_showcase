#! /usr/bin/env python
#
# Support module generated by PAGE version 4.9
# In conjunction with Tcl version 8.6
#    Oct 20, 2017 11:35:29 AM


import sys
try:
    from Tkinter import *
except ImportError:
    from tkinter import *
try:
    import ttk
    py3 = 0
except ImportError:
    import tkinter.ttk as ttk
    py3 = 1
try:
    from StringIO import StringIO
except ImportError:
    from io import StringIO

import time
import zmq
from _thread import start_new_thread
import matplotlib
matplotlib.use("TkAgg")
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2TkAgg
from matplotlib.figure import Figure
import matplotlib.pyplot as plt
import numpy
import numpy as np
import networkx as nx
import matplotlib
from matplotlib import rcParams
import urllib
from urllib import request
rcParams.update({'figure.autolayout': True})
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
matplotlib.use("TkAgg")
import PIL
from PIL import Image
from selenium import webdriver
# from spectral_acquire import spectral_recorder
from operator import itemgetter

zigbeeActivation = None

def set_Tk_var():
    global wifiActivation, zigbeeActivation, lteActivation, microwaveActivation
    wifiActivation = StringVar(None,"0")
    zigbeeActivation = StringVar(None,"0")
    lteActivation = StringVar(None,"0")
    microwaveActivation = StringVar(None,"0")


def OpenFileDialog():
    print('gui_support.OpenFileDialog')
    sys.stdout.flush()

def Quit():
    print('gui_support.Quit')
    sys.stdout.flush()
    destroy_window()

def Save():
    print('gui_support.Save')
    sys.stdout.flush()

def StartGatewayCommand():
    print('gui_support.StartGatewayCommand')
    sys.stdout.flush()

def StopGatewayCommand():
    print('gui_support.StopGatewayCommand')
    sys.stdout.flush()

def init(top, gui, *args, **kwargs):
    global w, top_level, root
    w = gui
    top_level = top
    root = top

    global my_dpi, width, height
    my_dpi = 100
    width = 600
    height = 300

    global all_nodes, network_nodes
    # all_nodes = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I']
    # network_nodes = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I']
    all_nodes = ['A', 'B', 'C']
    network_nodes = ['A', 'B', 'C']

    # global bar_wifi, bar_zigbee, bar_microwave, bar_lte, bar_burst
    global bar_badfcs, bar_badplcp, bar_goodplcp, bar_goodfcs
    global bar_badfcs_norm, bar_badplcp_norm, bar_goodplcp_norm, bar_goodfcs_norm

    # bar_wifi = 20
    # bar_zigbee = 40
    # bar_lte = 60
    # bar_microwave = 80
    # bar_burst = 500
    bar_badfcs=20
    bar_badplcp=20
    bar_goodplcp=20
    bar_goodfcs=20
    bar_badfcs_norm=20
    bar_badplcp_norm=20
    bar_goodplcp_norm=20
    bar_goodfcs_norm=20


    global driver, wifiActivation, zigbeeActivation, lteActivation, microwaveActivation
    chrome_driver = False
    if chrome_driver:
        path = "C:\Program Files\Python34\selenium\webdriver\chrome\chromedriver.exe"
        driver = webdriver.Chrome(path)
        # driver.get("http://10.8.8.22/energenie.html")
        driver.get("http://localhost:8001/energenie.html")
        zigbeeActivation.trace("w", change_state_zigbee)

    wifiActivation.trace("w", change_state_wifi)
    lteActivation.trace("w", change_state_lte)
    microwaveActivation.trace("w", change_state_microwave)

    # NETWORK SOCKET SETUP
    global socket_plot_remote_network, socket_command_remote_network, socket_spectral_remote_network
    print('Network socket setup')
    command_list = {}

    # connect to the wilabtestbed
    socket_command_remote_network_port = 8500
    context1_remote_network = zmq.Context()
    print("Connecting to server on port 8500 ... ready to send command to demo experiment node")
    socket_command_remote_network = context1_remote_network.socket(zmq.PAIR)
    socket_command_remote_network.connect("tcp://localhost:%s" % socket_command_remote_network_port)

    socket_plot_remote_network_port = 8501
    context2_remote_network = zmq.Context()
    print("Connecting to server on port 8501 ... ready to receive protocol information from demo experiment node")
    socket_plot_remote_network = context2_remote_network.socket(zmq.PULL)
    socket_plot_remote_network.bind("tcp://*:%s" % socket_plot_remote_network_port)

    socket_spectral_remote_network_port = 8502
    context3_remote_network = zmq.Context()
    print("Connecting to server on port 8502 ... ready to receive protocol information from Spectral Scan node")
    socket_spectral_remote_network = context3_remote_network.socket(zmq.SUB)
    socket_spectral_remote_network.connect("tcp://10.8.8.5:%s" % socket_spectral_remote_network_port)
    #socket_spectral_remote_network.connect("tcp://localhost:%s" % socket_spectral_remote_network_port)
    socket_spectral_remote_network.setsockopt(zmq.SUBSCRIBE, b'')



    start_new_thread(receive_data_plot, (99,))

    # PLOTTER bar detection
    start_new_thread(plot_bar_detection, (99,))

    # PLOTTER channet time
    # start_new_thread(plot_channel_time, (99,))

    # PLOTTER cdf time
    # start_new_thread(receive_data_spectral, (99,))


def destroy_window():
    # Function which closes the window.
    global top_level, driver

    driver.close()
    driver.quit()

    top_level.destroy()
    top_level = None


def mean(numbers):
    return float(sum(numbers)) / max(len(numbers), 1)


#*****************
#reveive data plot from controller
#*****************
def receive_data_plot(x):
    global socket_plot_remote_network, socket_command_remote_network
    # global bar_wifi, bar_zigbee, bar_microwave, bar_lte, bar_burst
    global bar_badfcs, bar_badplcp, bar_goodplcp, bar_goodfcs
    global bar_badfcs_norm, bar_badplcp_norm, bar_goodplcp_norm, bar_goodfcs_norm
    global all_nodes
    global w

    reading_time = 1000
    reading_time_sec = 1

    leg = ['Bad FCS', 'Bad PLCP', 'Good PLCP', 'Good FCS']
    # reg = {'104' '106' '108' '10A' '10C' '10E' '110' '112' '11E' '100'};
    # leg = {'Too Long' 'Too Short' 'Invalid MAC Header' 'Bad FCS' 'Bad PLCP'...
    # 'Preamble OK, bad Header' 'Good PLCP' 'Good FCS, matching RA' 'Good FCS, not matching RA' 'Busy Time'};
    # raw_tstamp = str2num(char(C(:, 1))); % tstamp
    # raw_err
    # {1} = str2num(char(C(:, 4))); % '104'
    # {2} = str2num(char(C(:, 5))); % '106'
    # {3} = str2num(char(C(:, 6))); % '108'
    # {4} = str2num(char(C(:, 7))); % '10A' 'Bad FCS'
    # {5} = str2num(char(C(:, 8))); % '10C' 'Bad PLCP'
    # {6} = str2num(char(C(:, 9))); % '10E'
    # {7} = str2num(char(C(:, 10))); % '110' 'Good PLCP'
    # {8} = str2num(char(C(:, 11))); % '112'
    # {9} = str2num(char(C(:, 17))); % '11E' 'Good FCS'
    # {10} = str2num(char(C(:, 2))); % '100'

    # use poll for timeouts:
    poller = zmq.Poller()
    poller.register(socket_plot_remote_network, zmq.POLLIN)

    logList = []
    listStart = True
    indexList = 0

    while True:    # Run until cancelled
        socks = dict(poller.poll(1000))
        if socket_plot_remote_network in socks:
            parsed_json = socket_plot_remote_network.recv_json()
        else:
            continue

        # print('parsed_json : %s' % str(parsed_json))
        if 'type' in parsed_json:
            # print('parsed_json : %s' % str(parsed_json))

            # if parsed_json['type'] == 'find_topology':
            #     self.update_topology_carrier_sense = True
            #     self.update_topology_carrier_sense_value = parsed_json['value']

            #{'measure': [[1513245709449775.5, 3558.99, 0.0, 3.76, 0.0, 36.59, 61.55, 23.05, 0.0, 197.79, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 132.51, 0.0, 1912.97], 0.0], 'mac_address': '00:14:a5:e9:12:7c',
            # 'type': 'statistics', 'label': 'A'}
            if parsed_json['type']=='statistics' and parsed_json['measure']:

                # if listStart:
                #     logList.append(str(parsed_json))
                #     w.ListboxLog.insert(END, logList[indexList])
                #     indexList += 1
                #     if indexList > 4:
                #         listStart = False
                # else:
                #     logList.pop(0)
                #     logList.append(str(parsed_json))
                #     w.ListboxLog.delete(0, END)  # clear listbox
                #     for log in logList:  # populate listbox again
                #         w.ListboxLog.insert(END, log)

                label = parsed_json['label']
                if label:
                    # print("%s %s" % (str(label) , str(parsed_json['measure'])))
                    measure = parsed_json['measure']
                    # thrMeasure = measure[1]
                    if label == all_nodes[0]:
                        errorMeasure = measure[0]
                        if len(errorMeasure)==19: #len(errorMeasure)==6: #check error only for labl A

                            # [event_wifi_number_1, event_zigbee_number_1, event_other_number_1, event_wifi_number_2, event_lte_number_2, event_other_number_2]
                            # event_wifi_number_1 = float(errorMeasure[0]); event_zigbee_number_1 = float(errorMeasure[1]); event_other_number_1 = float(errorMeasure[2]);
                            # event_wifi_number_2 = float(errorMeasure[3]); event_lte_number_2 = float(errorMeasure[4]); event_other_number_2 = float(errorMeasure[5]);

                            # event_wifi_number = mean([event_wifi_number_1, event_wifi_number_2])
                            # if event_other_number_1>event_zigbee_number_1 and event_other_number_2>event_lte_number_2:
                            #     event_other_number = mean([event_other_number_1, event_other_number_2])
                            # elif event_other_number_1>event_zigbee_number_1 and event_other_number_2<event_lte_number_2:
                            #     event_other_number = event_other_number_2
                            # elif event_other_number_1 < event_zigbee_number_1 and event_other_number_2 > event_lte_number_2:
                            #     event_other_number = event_other_number_1
                            # else:
                            #     event_other_number = mean([event_other_number_1, event_other_number_2])
                            # event_sum = event_wifi_number + event_zigbee_number_1 + event_lte_number_2 + event_other_number
                            # bar_wifi=event_wifi_number/event_sum*100
                            # bar_zigbee=event_zigbee_number_1/event_sum*100
                            # bar_lte=event_lte_number_2/event_sum*100
                            # bar_microwave=event_other_number/event_sum*100

                            # event_sum = event_wifi_number_1 + event_zigbee_number_1 + event_other_number
                            # bar_burst = event_sum
                            # bar_wifi=event_wifi_number_1/event_sum*100
                            # bar_zigbee=event_zigbee_number_1/event_sum*100
                            # bar_lte=0
                            # bar_microwave=event_other_number/event_sum*100
                            # print(event_sum)
                            # print([bar_wifi, bar_zigbee, bar_lte, bar_microwave])

                            # {'measure': [1509111511254766.8, 42484.30757322044, 0.0, 29932.280465072192, 395.0, 30987.524880730467, 23422.818805093048, 22074.31423967647, 0.0, 45105.3260244542, 33.0, 0.0, 0.0, 0.0,
                            #              0.0, 0.0, 57253.20113108591, 0.0, 64.11999620865059]}
                            # {'measure': [2021779.0, -18678.609999999997, 0.0, 0.9000000000014552, 0.0, 20.55000000000291, 19.650000000001455, 4.7299999999959255, 0.0, 74.25, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
                            #              53.68999999999869, 0.0, 0.18999999999999773]}

                            # leg = ['Bad FCS', 'Bad PLCP', 'Good PLCP', 'Good FCS']
                            bar_badfcs = float(errorMeasure[6]); bar_badplcp=float(errorMeasure[7]); bar_goodplcp=float(errorMeasure[9]); bar_goodfcs=float(errorMeasure[16]);
                            error_sum = bar_badfcs + bar_badplcp + bar_goodplcp + bar_goodfcs
                            bar_badfcs_norm = bar_badfcs/error_sum*100; bar_badplcp_norm = bar_badplcp/error_sum*100; bar_goodplcp_norm = bar_goodplcp/error_sum*100; bar_goodfcs_norm = bar_goodfcs/error_sum*100;


                    else:
                        # print('Error in plot receive, wrong label present')
                        continue

                    # self.tv.item(item, text=label, values=(round(measure[1]*100)/100, round(measure[2]*100)/100, round(measure[3]*100)/100))
                else:
                    print('Error in plot receive, no label present')

            # {'eventList': ['interferenceDetected'], 'solution': 'InterferenceDetection', 'type': 'registerRequest', 'commandList': ['start', 'stop']}
            if parsed_json['type'] == 'registerRequest' or  parsed_json['type'] == 'monitorReport' or parsed_json['type'] == 'eventReport' or parsed_json['type'] == 'command':
                print('parsed_json : %s' % str(parsed_json))
                if listStart:
                    logList.append(str(parsed_json))
                    w.ListboxLog.insert(END, logList[indexList])
                    indexList += 1
                    if indexList > 4:
                        listStart = False
                else:
                    logList.pop(0)
                    logList.append(str(parsed_json))
                    w.ListboxLog.delete(0, END)  # clear listbox
                    for log in logList:  # populate listbox again
                        w.ListboxLog.insert(END, log)


def plot_bar_detection(x):
    # global bar_wifi, bar_zigbee, bar_microwave, bar_lte, bar_burst
    global bar_badfcs, bar_badplcp, bar_goodplcp, bar_goodfcs
    global bar_badfcs_norm, bar_badplcp_norm, bar_goodplcp_norm, bar_goodfcs_norm
    global my_dpi, width, height
    global w

    init = 1
    while True:
        if init:
            try:
                # plt.ion()
                figure_bar_detection = Figure()
                # self.figure_busytime = plt.figure()
                figure_bar_detection.set_facecolor('white')

                # ax1 = figure_bar_detection.add_subplot(1, 2, 1)
                ax1 = figure_bar_detection.add_subplot(1, 1, 1)
                ax1.grid(True)
                ax1.set_xlabel('Techonology', fontsize=12)
                ax1.set_ylabel('%')
                # interference_labels = ['', 'WiFi', 'ZigBee', 'LTE', 'MicroWave', '']
                interference_labels = ['', 'Bad FCS', 'Bad PLCP', 'Good PLCP', 'Good FCS', '']
                interference_tick = [0, 1, 2, 3, 4]
                ax1.set_xticklabels(interference_labels)
                ind = [1,2,3,4]  # the x locations for the groups
                width_bar = 0.35  # the width of the bars
                bar_array = [bar_badfcs_norm, bar_badplcp_norm, bar_goodplcp_norm, bar_goodfcs_norm]
                # bar_array = [bar_wifi, bar_zigbee, bar_lte, bar_microwave]
                barlist1 = ax1.bar(ind, bar_array, width_bar)

                barlist1[0].set_color('y')
                height_label_barlist1 = barlist1[0].get_height()
                barlist1Text0 = ax1.text(barlist1[0].get_x() + barlist1[0].get_width() / 2, height_label_barlist1 + 80, [bar_badfcs], ha='center', va='bottom')

                barlist1[1].set_color('b')
                height_label_barlist1 = barlist1[1].get_height()
                barlist1Text1 = ax1.text(barlist1[1].get_x() + barlist1[1].get_width() / 2, height_label_barlist1 + 80, [bar_badplcp], ha='center', va='bottom')

                barlist1[2].set_color('k')
                height_label_barlist1 = barlist1[2].get_height()
                barlist1Text2 = ax1.text(barlist1[2].get_x() + barlist1[2].get_width() / 2, height_label_barlist1 + 80, [bar_goodplcp], ha='center', va='bottom')

                barlist1[3].set_color('g') #rgbkymc
                height_label_barlist1 = barlist1[3].get_height()
                barlist1Text3 = ax1.text(barlist1[3].get_x() + barlist1[3].get_width() / 2, height_label_barlist1 + 80, [bar_goodfcs], ha='center', va='bottom')

                ax1.set_ylim([0, 120])
                ax1.set_xlim([0, 5])

                # ax1.patch.set_facecolor('white')

                # ax2 = figure_bar_detection.add_subplot(1, 2, 2)
                # ax2.grid(True)
                # ax2.set_xlabel('Burst', fontsize=12)
                # ax2.set_ylabel('#')
                # burst_labels = ['', '', '']
                # # burst_labels = [0, 1, 2, ]
                # ax2.set_xticklabels(burst_labels)
                # ax2.set_ylim([0, 1800])
                # ax2.set_xlim([0, 1])
                # width_bar = 0.25  # the width of the bars
                # barlist2 = ax2.bar([0.5], [bar_burst], width_bar)
                # barlist2[0].set_color('k')
                # height_label_barlist2 = barlist2[0].get_height()
                # barlist2Text = ax2.text(barlist2[0].get_x() + barlist2[0].get_width() / 2, height_label_barlist2 + 1600 , [bar_burst], ha='center', va='bottom')


                figure_bar_detection.set_size_inches(width / my_dpi, height / my_dpi)
                canvas1 = FigureCanvasTkAgg(figure_bar_detection, w.LabelframeDetection1)
                canvas1.show()
                canvas1.get_tk_widget().configure(background='white', highlightcolor='white',highlightbackground='white')
                canvas1.get_tk_widget().grid(column=0, row=0, columnspan=1, sticky='nesw')
                canvas1.get_tk_widget().grid(column=0, row=0)

            except Exception as e:
                pass
            init = 0
        else:
            # barlist1[0].set_height(bar_wifi)
            # barlist1[1].set_height(bar_zigbee)
            # barlist1[2].set_height(bar_lte)
            # barlist1[3].set_height(bar_microwave)
            # barlist2[0].set_height(bar_burst)
            # barlist2Text.set_text(bar_burst)
            barlist1[0].set_height(bar_badfcs_norm)
            barlist1Text0.set_text(bar_badfcs)
            barlist1[1].set_height(bar_badplcp_norm)
            barlist1Text1.set_text(bar_badplcp)
            barlist1[2].set_height(bar_goodplcp_norm)
            barlist1Text2.set_text(bar_goodplcp)
            barlist1[3].set_height(bar_goodfcs_norm)
            barlist1Text3.set_text(bar_goodfcs)
            figure_bar_detection.canvas.draw()

        time.sleep(1)


def plot_channel_time(x):
    global w
    global my_dpi
    width = 1300
    height = 220
    #url open init
    im = None
    static = False
    init_loop_capture = True
    location = 'http://127.0.0.1:8002/crewdemo/plots/usrp.png'
    # location = 'http://10.8.9.3/crewdemo/plots/usrp.png'
    # location = 'http://10.8.8.4/crewdemo/plots/usrp.png'
    user_agent = 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.19 (KHTML, like Gecko) Ubuntu/12.04 Chromium/18.0.1025.168 Chrome/18.0.1025.168 Safari/535.19'
    #figure init
    plt.ion()
    f = Figure()
    f.patch.set_facecolor('#D9D9D9')
    #f.patch.set_alpha(0.7)
    #f.subplots_adjust(left=0, right=1, bottom=0, top=1)
    f.set_size_inches(width / my_dpi, height / my_dpi)
    # f.set_size_inches(11.7, 4.5)
    ax = f.add_subplot(111)
    #connect to labl frame
    canvas = FigureCanvasTkAgg(f, w.LabelframeMonitor)
    canvas.show()
    canvas.get_tk_widget().grid(column=0, row=0, columnspan=1, sticky='nesw')

    while True:
        if not static:
            if init_loop_capture:
                print('start usrp request')
                try:
                    file = urllib.request.urlopen(urllib.request.Request(location, headers={'User-Agent': user_agent}))
                    img = Image.open(file)
                    """
                    basewidth = 2000
                    wpercent = (basewidth / float(img.size[0]))
                    hsize = int((float(img.size[1]) * float(wpercent)))
                    """
                    basewidth=1000; hsize=250;
                    img = img.resize((basewidth, hsize), Image.ANTIALIAS)
                except Exception as e:
                    print(e)
                    try:
                        img = mpimg.imread("usrp.png")
                        static = 1
                    except Exception as e:
                        print(e)

                im = ax.imshow(img)
                ax.axes.get_xaxis().set_visible(False)
                ax.axes.get_yaxis().set_visible(False)
                init_loop_capture = 0
            else:
                try:
                    file = urllib.request.urlopen(urllib.request.Request(location, headers={'User-Agent': user_agent}))
                    if file:
                        try:
                            img = Image.open(file)
                            im.set_data(img)
                            f.canvas.draw()
                        except Exception as e:
                            print(e)
                            print('ERRORE open image')
                    else:
                        print('ERRORE download image')
                except Exception as e:
                    print(e)
                    print('ERRORE request image')

        time.sleep(1)


#*****************
#reveive data spectral from spectral node
#*****************
def receive_data_spectral(x):
    sr = spectral_recorder.SpectralRecorder(load=False)
    time.sleep(1)
    global socket_spectral_remote_network
    global all_nodes
    reading_time = 1000
    reading_time_sec = 1

    # init ZMQ socket
    poller = zmq.Poller()
    poller.register(socket_spectral_remote_network, zmq.POLLIN)
    # init figure
    plt.ioff()
    fig = plt.figure()
    fig.set_size_inches(1400 / 100.0, 580 / 100.0)
    #init canvas
    canvas1 = FigureCanvasTkAgg(fig, w.LabelframeWaterFall)
    canvas1.show()
    canvas1.get_tk_widget().configure(background='white', highlightcolor='white', highlightbackground='white')
    canvas1.get_tk_widget().grid(column=0, row=0, columnspan=1, sticky='nesw')
    canvas1.get_tk_widget().grid(column=0, row=0)

    while True:

        socks = dict(poller.poll(2000))
        if socket_spectral_remote_network in socks:
            #parsed_json = socket_spectral_remote_network.recv_json()
            spectral_raw = socket_spectral_remote_network.recv()
            f = open('/tmp/demo.tlv', 'wb')
            f.write(np.array(spectral_raw))
            f.close()

            try:

                [measurements, spectrum_features, duration_energy_det_features, duration_features, freq,power_features] = sr.get_spectrum_scan_features( "/tmp/demo.tlv", T=500e3)
                exp_name = "WaterFall"
                dd = np.array(list(map(itemgetter('duration'), duration_features)))  # duration detection via correlation
                bb = np.array(list(map(itemgetter('bw'), spectrum_features)))  # bandwidth
                ff2 = np.array(list(map(itemgetter('freq'), spectrum_features)))  # frequency
                ed = np.array(list(map(itemgetter('duration'), duration_energy_det_features)))  # duration via energy detection
                ed_t_start = np.array(list(map(itemgetter('tsf'), duration_energy_det_features)))  # duration via energy detection
                ed_t_stop  = np.array(list(map(itemgetter('tsf_stop'), duration_energy_det_features)))  # duration via energy detection

                p_av = np.array(
                    list(map(itemgetter('p_av'), power_features)))  # duration via energy detection
                p_av_w = np.array(
                    list(map(itemgetter('p_av_w'), power_features)))  # duration via energy detection
                tsf_p = np.array(
                    list(map(itemgetter('tsf_p'), power_features)))  # duration via energy detection

                fig.clf()
                #!!!! SUBPLOT 1
                # fig.suptitle(exp_name)
                ax_energy_detection = fig.add_subplot(322)
                # ax_energy_detection = fig.add_subplot(222)

                dd_s = np.sort(ed)
                yvals = np.arange(len(dd_s)) / float(len(dd_s) - 1)
                ax_energy_detection.plot(dd_s, yvals)
                # ax_energy_detection.set_xlim([-130,-90])
                ax_energy_detection.set_title('energy detection CDF size={}'.format(len(dd_s)));
                ax_energy_detection.set_xlabel('Duration [us]')
                ax_energy_detection.set_ylabel('CDF')
                ax_energy_detection.set_xlim([0,max(ed)])
                ax_energy_detection.grid()

                # !!!! SUBPLOT 2
                # ax_cdf_bw = fig.add_subplot(224)
                # ax_cdf_bw.plot(tsf_p,p_av)
                # ax_cdf_bw.plot(tsf_p, p_av_w,'--')
                # P_thr_db = -75
                # ax_cdf_bw.plot(tsf_p,[10 ** (P_thr_db / 10.0)] * len(tsf_p),'b--')
                # ax_cdf_bw.plot(ed_t_start, [10 ** (P_thr_db / 10.0)] * len(ed_t_start), 'g^')
                # ax_cdf_bw.plot(ed_t_stop, [10 ** (P_thr_db / 10.0)] * len(ed_t_stop), 'r^')
                # ax_cdf_bw.set_xlabel('Time [us]')
                # ax_cdf_bw.set_ylabel('POW')
                # ax_cdf_bw.grid()
                # ax_cdf_bw.set_ylim([0,4e-8])

                ax_cdf_bw = fig.add_subplot(324)

                bb = [j for i in bb for j in i]
                dd_s = np.sort(bb)
                yvals = np.arange(len(dd_s)) / float(len(dd_s) - 1)
                #max_bw,k_bw,v_bw = get_occurrences(bb)
                ax_cdf_bw.plot(dd_s, yvals)
                #ax_cdf_bw.plot(k_bw, np.cumsum(v_bw)/sum(v_bw),'b.')
                #ax_cdf_bw.stem(k_bw, v_bw/max(v_bw), 'b.--')
                # ax_cdf_bw.set_title('Expected bw CDF size={}'.format(len(dd_s)));
                ax_cdf_bw.set_title('Expected bw CDF');
                ax_cdf_bw.set_xlabel('BW [MHz]')
                ax_cdf_bw.set_ylabel('CDF')
                ax_cdf_bw.set_xlim([0, 20])
                ax_cdf_bw.grid()


                # !!!! SUBPLOT 3

                ax_cdf_ff = fig.add_subplot(326)
                ff2 = [j for i in ff2 for j in i]

                dd_s = np.sort(ff2)
                yvals = np.arange(len(dd_s)) / float(len(dd_s) - 1)
                ax_cdf_ff.plot(dd_s, yvals)
                ax_cdf_ff.set_title('Expected freq CDF');
                ax_cdf_ff.set_xlabel('freq [MHz]')
                ax_cdf_ff.set_ylabel('CDF')
                ax_cdf_ff.grid()
                f_spec=sr.get_freq_list(freq)
                fmin=min(f_spec)
                fmax=max(f_spec)
                ax_cdf_ff.set_xlim([fmin, fmax])

                # !!!! SUBPLOT 4
                # ax_cdf_duration = fig.add_subplot(428)
                # # IGNORE duration < 300
                # #dd = [i for i in dd if i >= 300]
                # dd_s = np.sort(dd)
                # yvals = np.arange(len(dd_s)) / float(len(dd_s) - 1)
                # try:
                #     max_corr=get_occurrences(dd)
                # except Exception as e:
                #     max_corr = -1
                # ax_cdf_duration.plot(dd_s, yvals)
                # ax_cdf_duration.set_title('correlation CDF size={}'.format(len(dd)));
                # ax_cdf_duration.set_xlabel('Duration [us]')
                # ax_cdf_duration.set_ylabel('CDF')
                # ax_cdf_duration.grid()

                ax_waterfall = fig.add_subplot(121)
                ax_waterfall = sr.plot_waterfall(ax_waterfall, measurements, exp_name)

                #print("----------------------")
                #print("AVERAGE FEATURES:")
                #print("max_bw   ={}".format(max_bw[0:5]))
                #print("max_freq ={}".format(max_freq[0:5]))
                #print("max_ed   ={}".format(max_ed[0:5]))
                #print("max_corr ={}".format(max_corr[0:5]))
                #print("max_bw   ={}".format(max_bw))
                #print("k_bw   ={}".format(k_bw))
                #print("v_bw   ={}".format(v_bw))
                #print("max_freq ={}".format(max_freq))
                #print("max_ed   ={}".format(max_ed[0:5]))
                #print("max_corr ={}".format(max_corr[0:5]))
                #print("----------------------")
                plt.tight_layout()
                # fig.savefig("{}.png".format("spcetral_plot"),dpi=(150))
                fig.canvas.draw()
                #plt.close()

            except Exception as e:
                #print(e)
                continue


def get_occurrences(v):
    occ=[]
    occ_key=[]
    occ_val=[]
    v=list(v)
    try:
        occ = [[x, v.count(x)] for x in set(v)]
        occ.sort(key=lambda x: x[0])
        #occ = occ[::-1]
        occ=np.array(occ)
        occ_key = list(occ[:,0])
        occ_val = list(occ[:,1])
    except Exception as e:
        pass
        #print(e)
    return occ,occ_key, occ_val


def change_state_zigbee(*args):
    global driver
    print('gui_support.change_state_zigbee')
    sys.stdout.flush()
    driver.execute_script("ChangeState('1')")


def change_state_lte(*args):
    global driver, lteActivation
    print('gui_support.change_state_lte : ' + lteActivation.get())
    sys.stdout.flush()
    setTraffic("LTE")


def change_state_microwave(*args):
    global driver, microwaveActivation
    print('gui_support.change_state_microwave')
    sys.stdout.flush()
    # driver.execute_script("ChangeState('4')")
    if microwaveActivation.get()=='1':
        command = 'set_wave'
    else:
        command = 'off_wave'
    command_list = {'type': 'microwave', 'command': command}
    print('command sent %s' % str(command_list))
    socket_command_remote_network.send_json(command_list)


def change_state_wifi(*args):
    global driver, wifiActivation
    print('gui_support.change_state_wifi : ' + wifiActivation.get())
    sys.stdout.flush()
    setTraffic("WIFI")


def stopAllTraffic(self):
    global socket_command_remote_network
    command = 'off_traffic'
    dst = 'A'
    for label in all_nodes:
        stop_command = {'type': 'traffic', 'command': command, 'src': label, 'dst': dst}
        print('command sent %s' % str(stop_command))
        socket_command_remote_network.send_json(stop_command)
        time.sleep(0.5)


def setTraffic(technology):
    global socket_command_remote_network, wifiActivation
    MAX_SOURCE_TRAFFIC = 20000

    # print(src)
    # source_rate = int(val[self.all_nodes.index(src)].get())
    # dst = self.countryVar[self.all_nodes.index(src)].get()

    if technology=="WIFI":
        dst = 'B'
        src = 'C'
        if wifiActivation.get() == '1':
            source_rate = 2000
        else:
            source_rate = 0
    elif technology=="LTE":
        dst = 'E'
        src = 'D'
        if lteActivation.get()=='1':
            source_rate = 2000
        else:
            source_rate = 0
    else:
        return

    if src != dst:
        if 500 < source_rate and source_rate <= MAX_SOURCE_TRAFFIC:
            round_val = round(source_rate/1000)*1000
            command = 'set_traffic'
            command_list = {'type': 'traffic', 'command': command, 'src' : src, 'dst' : dst, 'value' : round_val}
        else:
            round_val = 0
            command = 'off_traffic'
            command_list = {'type': 'traffic', 'command': command, 'src' : src, 'dst' : dst}

        print('command sent %s' % str(command_list))
        socket_command_remote_network.send_json(command_list)
        command_sent = True


if __name__ == '__main__':
    import gui
    gui.vp_start_gui()


