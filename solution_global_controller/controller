#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Usage:
   controller [options] [-q | -v]

Options:
   --logfile name       Name of the logfile
   --config configFile Config file path

Example:
   ./

Other options:
   -h, --help           show this help message and exit
   -q, --quiet           print less text
   -v, --verbose       print more text
   --version           show version and exit
"""

__author__ = "Domenico Garlisi, ...."
__copyright__ = "Copyright (c) ..., "
__version__ = "0.1.0"
__email__ = "domenico.garlisi@cnit.it; ..."

import threading
import datetime
import logging
import sys
import time
import gevent
import signal
import os
import yaml
import zmq
import json
import zmq
import _thread
import struct # for packing integers

sys.path.append('../')
from lib.kvsimple import KVMsg
from lib.zhelpers import zpipe

log = logging.getLogger('wishful_agent.main')

sequence_publisher = 0

class Solution:
    """
    Structure to store solutions in order to get compatibility matrix
    """
    id = 0
    name = None
    commandList=None
    eventList = None
    solutionCompatibilityList = None

    def __init__(self, id, name, commandList=None, eventList=None,  monitorList=None, solutionCompatibilityList=None):
        self.id = id
        self.name = name
        self.commandList = commandList
        self.eventList = eventList
        self.monitorList = monitorList
        self.solutionCompatibilityList = solutionCompatibilityList

    def store(self, dikt):
        """Store me in a dict if I have anything to store"""
        if self.id != 0 and self.name is not None:
            dikt[self.name] = self

def start_visualizer_connection():
    """
    ****    SETUP LOG GUI VISUALIZER    ****
    This function is used to setup the connection with the experiment GUI,
    a ZMQ socket client is created on port 8501, able to send statistical information to GUI
    """
    socket_visualizer_port = "8501"
    context = zmq.Context()
    socket_visualizer = context.socket(zmq.PUSH)
    socket_visualizer.connect("tcp://10.8.8.21:%s" % socket_visualizer_port)
    print("Connecting to server on port %s ... ready to send information to experiment GUI" % socket_visualizer_port)
    return socket_visualizer

def start_command_connection():
    """
    ****    SETUP COMMAND GUI VISUALIZER    ****
    This function is used to setup the connection with the experiment GUI,
    a ZMQ socket server is created on port 8500, able to receive command from GUI
    """
    socket_command_visualizer_port = "8500"
    context = zmq.Context()
    socket_command_visualizer = context.socket(zmq.PAIR)
    socket_command_visualizer.bind("tcp://*:%s" % socket_command_visualizer_port)
    print("Create server on port %s ... ready to receive command from experiment GUI" % socket_command_visualizer_port)
    return socket_command_visualizer


def send_command(publisher, command, to_solution):
    global sequence_publisher
    
    commandList = command
    sequence_publisher += 1
    msg = {"type": "publisherUpdate", "involvedSolutions": to_solution.name, "commandList": commandList}
    print("Sending update {} to {}".format(msg, to_solution.name))
    
    kvmsg = KVMsg(sequence_publisher)
    kvmsg.key = b"generic"
    kvmsg.body = json.dumps(msg).encode('utf-8')
    kvmsg.send(publisher)
    print("sent update information with sequence %d" % sequence_publisher)

def main(args):
    global sequence_publisher
    #Init variables
    kvmap = {}
    solutionCompatibilityMatrix = {}
    solutionNum = 0
    sequence_publisher = 0

    log.info('*******     WISHFUL *************')
    log.info('********  Starting solution global controller ***************')

    # all_nodes = ['B', 'C', 'D', 'E']
    # nodes_source_rate = []

    # Prepare our context and publisher socket
    ctx = zmq.Context()

    # Init Publisher socket
    publisher = ctx.socket(zmq.PUB)
    publisher.bind("tcp://*:7000")
    updates, peer = zpipe(ctx)

    # Init Request socket
    request = ctx.socket(zmq.ROUTER)
    request.bind("tcp://*:7001")
    poller = zmq.Poller()
    poller.register(request, zmq.POLLIN)

    # Init connection with GUI for LOG
    socket_visualizer = start_visualizer_connection()
    # Init conneciton with GUI for command
    socket_command_visualizer = start_command_connection()
    poller.register(socket_command_visualizer, flags=zmq.POLLIN)

    #Start main while, receive request and update information to solution
    while True:
        try:
            items = dict(poller.poll())
        except (zmq.ZMQError, KeyboardInterrupt):
            break # interrupt/context shutdown


        """
        **** RECEIVED MESSAGE FROM SHOWCASE SOLUTION
        """
        if request in items:
            msg = request.recv_multipart()
            identity = msg[0]
            try:
                received_request = json.loads(msg[3].decode("utf-8"))
            except ValueError:
                print("Received message not in json format")
                continue

            if "type" in received_request:
                # print(msg)
                socket_visualizer.send_json(received_request)

                #Process registration request
                if received_request["type"] == "registerRequest":
                    print("***Received registration request*** : %s\n" % received_request)
                    # print("***Received registration request*** :\n" )
                    # {"solution": "InterferenceDetection", "eventList": ["interferenceDetected"], "commandList": ["start", "stop"], "type": "registerRequest"}
                    if "solution" in received_request and "eventList" in received_request and "commandList" in received_request and "monitorList" in received_request:
                        solutionAlreadyPresent = received_request["solution"] in solutionCompatibilityMatrix
                        if not solutionAlreadyPresent:
                            solutionNum += 1
                            solution = Solution(solutionNum, received_request["solution"], received_request["commandList"], received_request["eventList"], received_request["monitorList"])
                            solution.store(solutionCompatibilityMatrix)

                        #TOBE
                        """
                        we need more attention when store the reference for a solution in the solutionCompatibilityMatrix, 
                        we need check the real conflict between the solutions in order to use it in the main logic of the 
                        solution global controller
                        """

                        responseMsg = {"type": "registerResponse", "result": "ok"}
                    else:
                        print("received malformed registration request")
                        responseMsg = {"type": "registerResponse", "result": "bad"}

                    # reply response to client
                    request.send(identity, zmq.SNDMORE)
                    # print('msg %s' % str(responseMsg))
                    # Distribute as key-value message
                    sequence = struct.unpack('!l',msg[2])[0] + 1
                    kvmsg = KVMsg(sequence)
                    kvmsg.key = b"generic"
                    kvmsg.body = json.dumps(responseMsg).encode('utf-8')
                    kvmsg.send(request)

                # Process monitoring Report
                if received_request["type"] == "monitorReport":
                    # print("*** Received monitoring report *** : %s" % received_request)
                    if len(solutionCompatibilityMatrix)>0:
                        #TOBE
                        """
                        This is the main logic of the solution global controller, after receiving a monitor report, the 
                        solution global controller, check the solution compatibility matrix, in order to understand 
                        eventually conflict, and send update/command to solution.
                        Example: when it receive the report of detecting interference (LTE), send command to solution TDMA cross interference, if not conflict are detected  
                        """
                        pass

                    else:
                        print("Received monitor report but no solution is registered")

                # Process monitoring Report
                if received_request["type"] == "eventReport":
                    print("*** Received event report *** : %s" % received_request)
                    # print("*** Received event report *** : \n" )
                    if len(solutionCompatibilityMatrix) > 0:
                        # TOBE
                        """
                        This is the main logic of the solution global controller, after receiving a event report, the 
                        solution global controller, check the solution compatibility matrix, in order to understand 
                        eventually conflict, and send update/command to solution.
                        Example: when it receive the report of detecting interference (LTE), send command to solution TDMA cross interference, if not conflict are detected  
                        """
                        if received_request["solution"] in solutionCompatibilityMatrix:
                            solution_origin = solutionCompatibilityMatrix[received_request["solution"]]
                            print("Received event from {}: {}".format(solution_origin.name, received_request))
                            if received_request["eventType"] == "WiFi_DETECTED":
                                if "lte_ct" in solutionCompatibilityMatrix:
                                   send_command(publisher, "START_TDMA", solutionCompatibilityMatrix["lte_ct"])
                                elif "6lowpan_blacklisting" in solutionCompatibilityMatrix:
                                   send_command(publisher, "6LOWPAN_BLACKLIST", solutionCompatibilityMatrix["6lowpan_blacklisting"])
                            elif received_request["eventType"] == "LTE_DETECTED":
                                if "lte_ct" in solutionCompatibilityMatrix:
                                   send_command(publisher, "START_TDMA", solutionCompatibilityMatrix["lte_ct"])
                                elif "6lowpan_blacklisting" in solutionCompatibilityMatrix:
                                   send_command(publisher, "6LOWPAN_BLACKLIST", solutionCompatibilityMatrix["6lowpan_blacklisting"])
                            elif received_request["eventType"] == "NO_interference":
                                if "lte_ct" in solutionCompatibilityMatrix:
                                   send_command(publisher, "START_TDMA", solutionCompatibilityMatrix["lte_ct"])
                                elif "6lowpan_blacklisting" in solutionCompatibilityMatrix:
                                   send_command(publisher, "6LOWPAN_WHITELIST", solutionCompatibilityMatrix["6lowpan_blacklisting"])
                        else:
                            print("Received event report but no solution is registered")

                # Process command Report
                if received_request["type"] == "commandReport":
                    print("*** Received command report *** : %s\n" % received_request)
                    if len(solutionCompatibilityMatrix) > 0:
                        pass
                    else:
                        print("Received command report but no solution is registered")


        """
        **** RECEIVED COMMAND FROM SHOWCASE GUI
        """
        if socket_command_visualizer in items:
            parsed_json = socket_command_visualizer.recv_json()
            print('parsed_json : %s' % str(parsed_json))
            type = parsed_json['type']
            if type == 'traffic':
                node = parsed_json['src']
                # node_src_index = all_nodes.index(node)
                command = parsed_json['command']
                # nodes_source_rate[node_src_index] = 0
                if command == 'off_traffic':
                    # if off traffic is selected for a specific node
                    if node == 'D':
                        #off LTE network
                        commandList = "STOP_LTE"
                        for key2 in solutionCompatibilityMatrix:
                            if solutionCompatibilityMatrix[key2].name == "lte_ct":
                                if commandList in solutionCompatibilityMatrix[key2].commandList:
                                    # Distribute as key-value message
                                    sequence_publisher += 1
                                    kvmsg = KVMsg(sequence_publisher)
                                    kvmsg.key = b"generic"
                                    msg = {"type": "publisherUpdate", "involvedSolutions": solutionCompatibilityMatrix[key2].name, "commandList": commandList}
                                    print('update message %s' % str(msg))
                                    kvmsg.body = json.dumps(msg).encode('utf-8')
                                    kvmsg.send(publisher)
                                    print("sent update information with sequence %d" % sequence_publisher)
                                break
                    else:
                        # off WiFi network
                        commandList = "STOP_WIFI"
                        for key2 in solutionCompatibilityMatrix:
                            if solutionCompatibilityMatrix[key2].name == "lte_ct":
                                if commandList in solutionCompatibilityMatrix[key2].commandList:
                                    # Distribute as key-value message
                                    sequence_publisher += 1
                                    kvmsg = KVMsg(sequence_publisher)
                                    kvmsg.key = b"generic"
                                    msg = {"type": "publisherUpdate", "involvedSolutions": solutionCompatibilityMatrix[key2].name, "commandList": commandList}
                                    print('update message %s' % str(msg))
                                    kvmsg.body = json.dumps(msg).encode('utf-8')
                                    kvmsg.send(publisher)
                                    print("sent update information with sequence %d" % sequence_publisher)
                                break

                # if start traffic is selected for a specific node
                if command == 'set_traffic':
                    node = parsed_json['dst']
                    # node_dst_index = all_nodes.index(node)
                    # value = parsed_json['value']
                    # nodes_source_rate[node_src_index] = value
                    # source_rate = float(nodes_source_rate[node_src_index])
                    # call UPI to start traffic
                    if node == 'E':
                        # on LTE network
                        commandList = "START_LTE"
                        for key2 in solutionCompatibilityMatrix:
                            if solutionCompatibilityMatrix[key2].name == "lte_ct":
                                if commandList in solutionCompatibilityMatrix[key2].commandList:
                                    # Distribute as key-value message
                                    sequence_publisher += 1
                                    kvmsg = KVMsg(sequence_publisher)
                                    kvmsg.key = b"generic"
                                    msg = {"type": "publisherUpdate", "involvedSolutions": solutionCompatibilityMatrix[key2].name, "commandList": commandList}
                                    print('update message %s' % str(msg))
                                    kvmsg.body = json.dumps(msg).encode('utf-8')
                                    kvmsg.send(publisher)
                                    print("sent update information with sequence %d" % sequence_publisher)
                                break

                    else:
                        # on WiFi network
                        commandList = "START_WIFI"
                        for key2 in solutionCompatibilityMatrix:
                            if solutionCompatibilityMatrix[key2].name == "lte_ct":
                                if commandList in solutionCompatibilityMatrix[key2].commandList:
                                    # Distribute as key-value message
                                    sequence_publisher += 1
                                    kvmsg = KVMsg(sequence_publisher)
                                    kvmsg.key = b"generic"
                                    msg = {"type": "publisherUpdate", "involvedSolutions": solutionCompatibilityMatrix[key2].name, "commandList": commandList}
                                    print('update message %s' % str(msg))
                                    kvmsg.body = json.dumps(msg).encode('utf-8')
                                    kvmsg.send(publisher)
                                    print("sent update information with sequence %d" % sequence_publisher)
                                break

            if type == 'radio_program':
                command = parsed_json['command']
                if command == 'on_tdma':
                    for key2 in solutionCompatibilityMatrix:
                        if solutionCompatibilityMatrix[key2].name == "lte_ct":
                            if "START_TDMA" in solutionCompatibilityMatrix[key2].commandList:
                                commandList = "START_TDMA"
                                # Distribute as key-value message
                                sequence_publisher += 1
                                kvmsg = KVMsg(sequence_publisher)
                                kvmsg.key = b"generic"
                                msg = {"type": "publisherUpdate", "involvedSolutions": solutionCompatibilityMatrix[key2].name, "commandList": commandList}
                                print('update message %s' % str(msg))
                                kvmsg.body = json.dumps(msg).encode('utf-8')
                                kvmsg.send(publisher)
                                print("sent update information with sequence %d" % sequence_publisher)
                            break
                if command == 'off_tdma':
                    for key2 in solutionCompatibilityMatrix:
                        if solutionCompatibilityMatrix[key2].name == "lte_ct":
                            if "STOP_TDMA" in solutionCompatibilityMatrix[key2].commandList:
                                commandList = "STOP_TDMA"
                                # Distribute as key-value message
                                sequence_publisher += 1
                                kvmsg = KVMsg(sequence_publisher)
                                kvmsg.key = b"generic"
                                msg = {"type": "publisherUpdate", "involvedSolutions": solutionCompatibilityMatrix[key2].name, "commandList": commandList}
                                print('update message %s' % str(msg))
                                kvmsg.body = json.dumps(msg).encode('utf-8')
                                kvmsg.send(publisher)
                                print("sent update information with sequence %d" % sequence_publisher)
                            break





if __name__ == "__main__":
    try:
        from docopt import docopt
    except:
        print(""" Please install docopt using:
            pip install docopt==0.6.1
            For more refer to: https://github.com/docopt/docopt """)
        raise

    args = docopt(__doc__, version=__version__)
    log_level = logging.INFO  # default
    if args['--verbose']:
        log_level = logging.DEBUG
    elif args['--quiet']:
        log_level = logging.ERROR

    logfile = None
    if args['--logfile']:
        logfile = args['--logfile']

    logging.basicConfig(filename=logfile, level=log_level,
        format='%(asctime)s - %(name)s.%(funcName)s() - %(levelname)s - %(message)s')

    #Get configuration file
    if args['--config']:
        config_file_path = args['--config']
        config = None
        with open(config_file_path, 'r') as f:
            config = yaml.load(f)
    try:
        main(args)
        print('end main')
    except KeyboardInterrupt:
        log.debug("Controller exits")
    finally:
        log.debug("Exit")
