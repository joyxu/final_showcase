#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Usage:
   controller [options] [-q | -v]

Options:
   --logfile name	   Name of the logfile
   --config configFile Config file path

Example:
   ./

Other options:
   -h, --help		   show this help message and exit
   -q, --quiet		   print less text
   -v, --verbose	   print more text
   --version		   show version and exit
"""

__author__ = "Domenico Garlisi, ...."
__copyright__ = "Copyright (c) ..., "
__version__ = "0.1.0"
__email__ = "domenico.garlisi@cnit.it; ..."

import threading
import datetime
import logging
import sys
import time
import gevent
import signal
import os
import yaml
import zmq
import json
import zmq
import _thread
import struct # for packing integers

sys.path.append('../')
from lib.kvsimple import KVMsg
from lib.zhelpers import zpipe

log = logging.getLogger('wishful_agent.main')

class Solution:
	"""
	Structure to store solutions in order to get compatibility matrix
	"""
	id = 0
	name = None
	commandList=None
	eventList = None
	solutionCompatibilityList = None

	def __init__(self, id, name, commandList=None, eventList=None,  monitorList=None, solutionCompatibilityList=None):
		self.id = id
		self.name = name
		self.commandList = commandList
		self.eventList = eventList
		self.monitorList = monitorList
		self.solutionCompatibilityList = solutionCompatibilityList

	def store(self, dikt):
		"""Store me in a dict if I have anything to store"""
		if self.id != 0 and self.name is not None:
			dikt[self.id] = self


def start_visualizer_connection():
	"""
					****	SETUP LOG VISUALIZER	****
	This function is used to setup the connection with the experiment GUI,
	a ZMQ socket client is created on port 8501, able to send statistical information to GUI
	"""
	socket_visualizer_port = "8501"
	context = zmq.Context()
	socket_visualizer = context.socket(zmq.PUSH)
	socket_visualizer.connect("tcp://10.8.8.21:%s" % socket_visualizer_port)
	print("Connecting to server on port %s ... ready to send information to experiment GUI" % socket_visualizer_port)

	return socket_visualizer


def main(args):
	#Init variables
	kvmap = {}
	solutionCompatibilityMatrix = {}
	solutionNum = 0
	sequence_publisher = 0

	log.info('******* 	WISHFUL *************')
	log.info('********  Starting solution global controller ***************')

	# Prepare our context and publisher socket
	ctx = zmq.Context()

	# Init Publisher socket
	publisher = ctx.socket(zmq.PUB)
	publisher.bind("tcp://*:7000")
	updates, peer = zpipe(ctx)

	# Init Request socket
	request = ctx.socket(zmq.ROUTER)
	request.bind("tcp://*:7001")
	poller = zmq.Poller()
	poller.register(request, zmq.POLLIN)

	# Init connection with GUI for LOG
	socket_visualizer = start_visualizer_connection()

	#Start main while, receive request and update information to solution
	while True:
		try:
			items = dict(poller.poll())
		except (zmq.ZMQError, KeyboardInterrupt):
			break # interrupt/context shutdown

		# Execute state request request
		if request in items:
			msg = request.recv_multipart()
			identity = msg[0]
			try:
				received_request = json.loads(msg[3].decode("utf-8"))
			except ValueError:
				print("Received message not in json format")
				continue

			if "type" in received_request:
				# print(msg)
				socket_visualizer.send_json(received_request)

				#Process registration request
				if received_request["type"] == "registerRequest":
					# print("***Received registration request*** : %s\n" % received_request)
					print("***Received registration request*** :\n" )
					# {"solution": "InterferenceDetection", "eventList": ["interferenceDetected"], "commandList": ["start", "stop"], "type": "registerRequest"}
					if "solution" in received_request and "eventList" in received_request and "commandList" in received_request and "monitorList" in received_request:
						solutionNum += 1
						solution = Solution(solutionNum, received_request["solution"], received_request["commandList"], received_request["eventList"], received_request["monitorList"])
						solution.store(solutionCompatibilityMatrix)

						#TOBE
						"""
						we need more attention when store the reference for a solution in the solutionCompatibilityMatrix, 
						we need check the real conflict between the solutions in order to use it in the main logic of the 
						solution global controller
						"""

						responseMsg = {"type": "registerResponse", "result": "ok"}
					else:
						print("received malformed registration request")
						responseMsg = {"type": "registerResponse", "result": "bad"}

					# reply response to client
					request.send(identity, zmq.SNDMORE)
					# print('msg %s' % str(responseMsg))
					# Distribute as key-value message
					sequence = struct.unpack('!l',msg[2])[0] + 1
					kvmsg = KVMsg(sequence)
					kvmsg.key = b"generic"
					kvmsg.body = json.dumps(responseMsg).encode('utf-8')
					kvmsg.send(request)

				# Process monitoring Report
				if received_request["type"] == "monitorReport":
					print("*** Received monitoring report *** : %s" % received_request)
					if len(solutionCompatibilityMatrix)>0:
						#TOBE
						"""
						This is the main logic of the solution global controller, after receiving a monitor report, the 
						solution global controller, check the solution compatibility matrix, in order to understand 
						eventually conflict, and send update/command to solution.
						Example: when it receive the report of detecting interference (LTE), send command to solution TDMA cross interference, if not conflict are detected  
						"""

						# Distribute as key-value message
						sequence_publisher += 1
						kvmsg = KVMsg(sequence_publisher)
						kvmsg.key = b"generic"
						solutionCompleteList = []
						for key in solutionCompatibilityMatrix:
							solutionCompleteList.append(solutionCompatibilityMatrix[key].name)

						# commandList = "activeTDMA"
						# msg = {"type": "publisherUpdate", "involvedSolutions": solutionCompleteList, "commandList": commandList}
						# print('update message %s' % str(msg))
						# kvmsg.body = json.dumps(msg).encode('utf-8')
						# kvmsg.send(publisher)
						# print("sent update information with sequence %d" % sequence_publisher)

					else:
						print("Received monitor report but no solution is registered")

				# Process monitoring Report
				if received_request["type"] == "eventReport":
					# print("*** Received event report *** : %s" % received_request)
					print("*** Received event report *** : \n" )
					if len(solutionCompatibilityMatrix) > 0:
						# TOBE
						"""
						This is the main logic of the solution global controller, after receiving a event report, the 
						solution global controller, check the solution compatibility matrix, in order to understand 
						eventually conflict, and send update/command to solution.
						Example: when it receive the report of detecting interference (LTE), send command to solution TDMA cross interference, if not conflict are detected  
						"""

						# Distribute as key-value message
						sequence_publisher += 1
						kvmsg = KVMsg(sequence_publisher)
						kvmsg.key = b"generic"
						solutionCompleteList = []
						for key in solutionCompatibilityMatrix:
							solutionCompleteList.append(solutionCompatibilityMatrix[key].name)
						commandList = "activeTDMA"
						msg = {"type": "publisherUpdate", "involvedSolutions": solutionCompleteList, "commandList": commandList}
						print('update message %s' % str(msg))
						kvmsg.body = json.dumps(msg).encode('utf-8')
						kvmsg.send(publisher)
						print("sent update information with sequence %d" % sequence_publisher)
					else:
						print("Received event report but no solution is registered")

				# Process command Report
				if received_request["type"] == "commandReport":
					print("*** Received command report *** : %s\n" % received_request)
					if len(solutionCompatibilityMatrix) > 0:
						pass
					else:
						print("Received command report but no solution is registered")


if __name__ == "__main__":
	try:
		from docopt import docopt
	except:
		print(""" Please install docopt using:
			pip install docopt==0.6.1
			For more refer to: https://github.com/docopt/docopt """)
		raise

	args = docopt(__doc__, version=__version__)
	log_level = logging.INFO  # default
	if args['--verbose']:
		log_level = logging.DEBUG
	elif args['--quiet']:
		log_level = logging.ERROR

	logfile = None
	if args['--logfile']:
		logfile = args['--logfile']

	logging.basicConfig(filename=logfile, level=log_level,
		format='%(asctime)s - %(name)s.%(funcName)s() - %(levelname)s - %(message)s')

	#Get configuration file
	if args['--config']:
		config_file_path = args['--config']
		config = None
		with open(config_file_path, 'r') as f:
			config = yaml.load(f)
	try:
		main(args)
		print('end main')
	except KeyboardInterrupt:
		log.debug("Controller exits")
	finally:
		log.debug("Exit")
